## 좋은 테스트의 FIRST 속성
단위 테스트는 주의 깊게 사용했을 때 많은 이점을 얻을 수 있다. 하지만 테스트 또한 작성하고 유지 보수해야 하는 또 다른 코드이다.  
다음은 피해야할 테스트 조건이다.  
 - 테스트를 사용하는 사람에게 어떤 정보도 주지 못하는 테스트
 - 산발적으로 실패하는 테스트
 - 어떤 가치도 증명하지 못하는 테스트
 - 실행하는 데 오래 걸리는 테스트
 - 코들르 충분히 커버하지 못하는 테스트
 - 구현과 강하게 결합되어 있는 테스트, 따라서 작은 변화에도 다수의 테스트가 깨진다.
 - 수많은 설정 고리로 점프하는 난해한 테스트
 
 그렇다면 좋은 테스트의 조건들에 대해 알아보자.
 
 ### 1. FIRST: 좋은 테스트 조건
 다음 FIRST 원리를 따르면 다누이 테스트 작성자가 흔히 빠지는 위험을 피할 수 있다.  
 - [F]ast: 빠른
 - [I]solated: 고립된
 - [R]epeatable: 반복 가능한
 - [S]elf-validating: 스스로 검증 가능한
 - [T]imely: 적시의
 
 #### 1-1. [F]IRST: 빠르다
 빠르다는 상대적인 개념이지만 시스템이 커져 단위 테스트의 실행이 하루에 서너 번 실행하기도 버겁다면 무언가 잘못된  
 방향으로 나아가고 있다는 것이다. 단위 테스트 스윗의 가치는 대상 시스템에 대한 지속적이고 종합적인 빠른 피드백을 주지 못하면  
 그만큼 저하된다. 모든 테스트의 의존성을 줄여 테스트를 빠르게 유지하라!  
 더 많은 로직을 커버하는 소수의 빠른 테스트는 데이터베이스 호출에 의존하는 단일 테스트보다 수월하게 실행될 것이다.  
 
테스트 코드는 빠르게 동작하며, 느린 것에 의존하는 코드를 최소화한다면 작성하기도 쉬워진다.  
코드를 클린 객체 지향 설계 개념과 맞출수록 단위 테스트 작성도 쉬워진다.  

#### 1-2. F[I]RST: 고립시킨다
좋은 단위 테스트는 검증하려는 작은 양의 코드에 집중한다. 직접적 혹은 간접적으로 테스트 코드와 상호 작용하는 코드가 많을수록  
문제가 발생할 소지가 늘어납니다.  

또 좋은 단위 테스트는 다른 단위 테스트에 의존하지 않는다. 즉, 테스트 코드는 어떤 순서나 시간에 관계없이 실행할 수 있어야 한다.  
각 테스트가 작은 양에 동작에만 집중하면 테스트 코드를 집중적이고 독립적으로 유지하기 쉬워진다.  
테스트에 두 번째 단언을 추가할 때 다음과 같이 스스로 질문해야 한다.  
 - "이들 단언이 단일 동작을 검증하도록 돕는가? 아니면 내가 새로운 테스트 이름으로 기술할 수 있는 어떤 동작을 대표하는가?"
 객체 지향 클래스 설계의 단일 책임 원칙에 따르면 클래스는 작고 단일한 목적을 가져야 한다. 좀 더 구체적으로 SRP는 클래스를  
 변경해야 할 이유가 하나만 있어야 한다고 말한다.  
   
 테스트 코드를 스위치처럼 만들어야 한다. 고립시켜 시계처럼 동작하게 하라.
 #### 1-3. FI[R]ST: 좋은 테스트는 반복 가능해야 한다
 반복 가능한 테스트는 실행할 때 마다 결과가 같이야 한다. 따라서 반복 가능한 테스트를 만들려면 직접 통제할 수 없는 외부 환경에  
 있는 항목들과 격리시켜야 한다. 하지만 시스템은 불가피하게 통제할 수 없는 요소와 상호 작용해야 한다. 예를 들어 현재 시간을  
 다루어야 한다면 테스트 코드는 반복 가능한 테스트를 힘들게 하는 불편한 요소가 된다. 이때는 테스트 대상 코드의 나머지를 격리하고  
 시간 변화에 독립성을 유지하는 방법으로 목 객체를 사용할 수 있다.  
 자바 8 에서는 java.time.Clock 객체를 사용하여 고정된 시간을 반환할 수 있다. 테스트에서 현재 시간을 얻으려는 코드에 가짜 Clock  
 객체를 넘길 수 있다. 아래와 같이 사용할 수 있다.
```
@Test
public void questionAnswersDateAdded() {
  Instant now = new Date().toInstant();
  controller.setClock(Clock.fixed(now, ZoneId.of("Asia/Seoul")));
  int id = controller.addQuestion("text");

  Question question = controller.find(id);
  
  assertThat(question.getCreateTimestamp()).isEqualTo(now);
}
```

만약 테스트코드에 반복성이 없다면 가장 최악의 순간에 놀랄 수도 있다. 설상가상으로 이러한 놀라운 상황이 가짜일 수도 있다.  
즉, 진짜 버그가 아니라 단지 테스트의 문제일 수도 있다. 유령 문제를 쫓아서 시간을 낭비할 필요가 없다.  
각 테스트는 항상 동일한 결과를 만들어 내야 한다!

#### 1-4.FIR[S]T: 스스로 검증 가능하다. 
테스트를 하기 위해 main() 메서드를 만들고 System.out.println() 메서드를 사용하지 마라.  
테스트 결과를 수동으로 검증하는 것은 시간 소모적인 절차고 리스크가 늘어난다. 멍해지기 쉽고 코드가 출력해 내는 거대한 로그를  
보다가 중요한 신호를 놓칠 수도 있다.  
  
테스트는 스스로 검증 가능할 뿐만 아니라 준비할 수도 있어야 한다. 테스트를 실행하기 전에 수동으로 준비 단계를 만드는 어리석은  
짓은 하지 말아라. 테스트에 필요한 어떤 설정 단계든 자동화를 해야 한다.  
  
IDE 에서는 Infinitest 좀 더 큰 규모에서는 젠킨스 혹은 TeamCity 같은 CI 도구를 사용한다. CI 도구는 소스 저장소를 관찰하여  
변화를 감지하면 빌드와 테스트 절차를 시작한다.  
한계는 없다. 이상적으로 만들어 낼 수 있는 모든 변화에 대한 테스트를 작성하는 시스템을 상상하라.  
코드를 소스 저장소에 통합할 때마다 빌드가 자동으로 수행되고 모든 테스트를 실행한다. 또 시스템이 허용 가능한 수준으로 건강한지  
알려준다. 빌드 서버는 확신 정도를 판단하고, 한 단계 나아가 프로덕션 시스템에 변경 사항을 반영한다.  

#### 1-5. FIRS[T]: 적시에 사용한다.
CI 환경에 자주 체크인하여 개발자들이 적시에 단위 테스트를 작성하는 습관을 들이도록 하고 하라. 그 팀은 테스트 코드가 시스템  
건강에 기여하는 것을 사랑할 것이다.
  
단위 테스트를 더 많이 할수록 테스트 대상 코드가 줄어든다. 그러면 먼저 단위 테스트 작성이 쉬워진다. 또 두번째로 새로운 코드를  
넣었을 때 테스트 효과가 즉시 나타난다.  
  
작은 규모로 코딩 다음 테스트 주기로 발전한다면 그 다음에는 테스트 다음 코드 단계를 고려하라.  
  
---------------------------

단위 테스트를 작성하는 것은 상당한 시간이 필요하다. 테스트 코드가 그에 상응하는 가치가 있다고 해도 이러한 테스트 코드 또한  
유지 보수 해야 한다. 테스트 코드를 고품질로 유지하여 이러한 투자를 보호하라.
